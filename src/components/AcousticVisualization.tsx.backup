'use client'

import React, { useState } from 'react'

interface AcousticVisualizationProps {
  fluteLength: number
  baseFrequency: number
  holePositions: Array<{
    hole: number
    position: number
    frequency: number
    noteName: string
    error: boolean
  }>
  boreDiameter: number
}

export default function AcousticVisualization({
  fluteLength,
  baseFrequency,
  holePositions,
  boreDiameter
}: AcousticVisualizationProps) {
  const svgWidth = 800
  const svgHeight = 400
  const scale = (svgWidth - 100) / fluteLength
  const startX = 50
  const centerY = svgHeight / 2
  
  // State for toggling waves visibility
  const [visibleWaves, setVisibleWaves] = useState<{[key: number]: boolean}>(() => {
    const initialState: {[key: number]: boolean} = { 0: true } // Base frequency always visible initially
    holePositions.forEach(hole => {
      initialState[hole.hole] = true
    })
    return initialState
  })
  
  // State for individual wave analysis
  const [selectedHole, setSelectedHole] = useState<number | null>(null)
  
  // State for zoom and hole visibility
  const [zoomLevel, setZoomLevel] = useState<number>(1)
  const [showHoles, setShowHoles] = useState<boolean>(true)
  const [panOffset, setPanOffset] = useState<number>(0)
  
  // Component visibility toggles
  const [showFundamental, setShowFundamental] = useState<boolean>(true)
  const [showHarmonics, setShowHarmonics] = useState<boolean>(true)
  const [showConcentration, setShowConcentration] = useState<boolean>(true)
  const [showSoundRadiation, setShowSoundRadiation] = useState<boolean>(true)
  const [showHoleIntersections, setShowHoleIntersections] = useState<boolean>(true)
  const [exaggerateWaves, setExaggerateWaves] = useState<boolean>(true)
  
  const toggleWave = (holeNumber: number) => {
    setVisibleWaves(prev => ({
      ...prev,
      [holeNumber]: !prev[holeNumber]
    }))
  }
  
  const handleZoom = (delta: number) => {
    setZoomLevel(prev => Math.max(0.5, Math.min(5, prev + delta)))
  }
  
  const resetView = () => {
    setZoomLevel(1)
    setPanOffset(0)
  }
  
  // Calculate wavelength and wave patterns
  const speedOfSound = 343000 // mm/s at room temperature
  
  const generateStandingWave = (frequency: number, effectiveLength: number, color: string, holePosition: number) => {
    const wavelength = speedOfSound / frequency
    const points: string[] = []
    const numPoints = Math.min(300, effectiveLength * 2) // More points for detailed waves
    const amplitude = 30
    
    // Calculate the effective acoustic length (considering end correction)
    const endCorrection = 0.6 * boreDiameter // Approximate end correction
    const acousticLength = effectiveLength + endCorrection
    
    for (let i = 0; i <= numPoints; i++) {
      const position = (i / numPoints) * effectiveLength
      const x = startX + position * scale
      
      // Standing wave pattern with proper boundary conditions
      // For a tube closed at one end: pressure node at closed end, antinode at open end
      const k = (2 * Math.PI) / wavelength
      const standingWaveAmplitude = Math.cos(k * (acousticLength - position))
      const y = centerY + amplitude * standingWaveAmplitude * 0.6
      
      points.push(`${x},${y}`)
    }
    
    // Calculate acoustic quality - how well the hole aligns with pressure antinode
    const k = (2 * Math.PI) / wavelength
    const pressureAtHole = Math.abs(Math.cos(k * (acousticLength - holePosition)))
    const acousticQuality = pressureAtHole // Higher = better acoustic coupling
    
    return {
      wave: (
        <polyline
          key={`wave-${frequency}`}
          points={points.join(' ')}
          fill="none"
          stroke={color}
          strokeWidth="2"
          opacity="0.8"
        />
      ),
      quality: acousticQuality
    }
  }
  
  // Generate pressure nodes and antinodes visualization
  const generateResonanceNodes = (frequency: number, effectiveLength: number) => {
    const wavelength = speedOfSound / frequency
    const k = (2 * Math.PI) / wavelength
    const endCorrection = 0.6 * boreDiameter
    const acousticLength = effectiveLength + endCorrection
    const nodes = []
    
    // Find pressure nodes (minima) - where cos(kx) = 0
    for (let n = 0; n < 10; n++) {
      const nodePosition = acousticLength - (wavelength / 4) * (2 * n + 1)
      if (nodePosition >= 0 && nodePosition <= effectiveLength) {
        nodes.push({
          position: nodePosition,
          type: 'node',
          amplitude: 0
        })
      }
    }
    
    // Find pressure antinodes (maxima) - where cos(kx) = ±1
    for (let n = 0; n < 10; n++) {
      const antinodePosition = acousticLength - (wavelength / 2) * n
      if (antinodePosition >= 0 && antinodePosition <= effectiveLength) {
        nodes.push({
          position: antinodePosition,
          type: 'antinode',
          amplitude: 1
        })
      }
    }
    
    return nodes
  }
  
  // Render visual holes on the flute
  const renderFluteholes = (transform: string = '') => {
    if (!showHoles) return null
    
    return holePositions.map((hole, index) => {
      const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#34495e']
      const color = colors[index % colors.length]
      const holeRadius = (boreDiameter * scale * zoomLevel) / 8 // Proportional to bore size
      const x = startX + hole.position * scale * zoomLevel + panOffset
      const y = centerY + (boreDiameter * scale * zoomLevel) / 2 // Bottom bore line
      
      return (
        <g key={`hole-${hole.hole}`} transform={transform}>
          {/* Hole opening - on bottom bore line */}
          <circle
            cx={x}
            cy={y}
            r={Math.max(2, holeRadius)}
            fill="#2c3e50"
            stroke={color}
            strokeWidth="2"
            opacity="0.9"
          />
          
          {/* Hole rim */}
          <circle
            cx={x}
            cy={y}
            r={Math.max(3, holeRadius + 1)}
            fill="none"
            stroke={color}
            strokeWidth="1"
            opacity="0.6"
          />
          
          {/* Hole number label - above the hole */}
          <text
            x={x}
            y={y - (holeRadius + 8)}
            fontSize="11"
            fill={color}
            textAnchor="middle"
            fontWeight="bold"
          >
            #{hole.hole}
          </text>
          
          {/* Note name below the hole */}
          <text
            x={x}
            y={y + (holeRadius + 18)}
            fontSize="9"
            fill={color}
            textAnchor="middle"
          >
            {hole.noteName}
          </text>
        </g>
      )
    })
  }
  
  // Individual wave analysis component
  const IndividualWaveAnalysis = ({ hole, holeData }: { hole: number, holeData: any }) => {
    const verticalSvgWidth = 400  // Vertical orientation
    const verticalSvgHeight = 600 // Taller for vertical layout
    const fundamental = holeData.frequency
    const octave = fundamental * 2
    const effectiveLength = holeData.position
    const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#34495e']
    const baseColor = colors[(hole - 1) % colors.length]
    
    // Vertical orientation parameters
    const verticalScale = (verticalSvgHeight - 100) / fluteLength
    const startY = 50
    const boreWidth = boreDiameter * verticalScale * 0.8
    const exaggeration = exaggerateWaves ? 3.0 : 1.0  // Exaggerate wave amplitude
    
    return (
      <div className="mt-6 p-4 bg-white border border-gray-200 rounded-lg">
        <h4 className="text-lg font-semibold mb-4" style={{ color: baseColor }}>
          Hole #{hole} ({holeData.noteName}) - Individual Wave Analysis
        </h4>
        
        {/* Toggle Controls */}
        <div className="mb-4 p-3 bg-gray-50 rounded-lg">
          <h6 className="font-medium text-gray-700 mb-2">Display Controls</h6>
          <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
            <label className="flex items-center gap-2 text-sm">
              <input 
                type="checkbox" 
                checked={showFundamental} 
                onChange={(e) => setShowFundamental(e.target.checked)}
                className="rounded"
              />
              Fundamental Wave
            </label>
            <label className="flex items-center gap-2 text-sm">
              <input 
                type="checkbox" 
                checked={showHarmonics} 
                onChange={(e) => setShowHarmonics(e.target.checked)}
                className="rounded"
              />
              Harmonics
            </label>
            <label className="flex items-center gap-2 text-sm">
              <input 
                type="checkbox" 
                checked={showConcentration} 
                onChange={(e) => setShowConcentration(e.target.checked)}
                className="rounded"
              />
              Wave Concentration
            </label>
            <label className="flex items-center gap-2 text-sm">
              <input 
                type="checkbox" 
                checked={showSoundRadiation} 
                onChange={(e) => setShowSoundRadiation(e.target.checked)}
                className="rounded"
              />
              Sound Radiation
            </label>
            <label className="flex items-center gap-2 text-sm">
              <input 
                type="checkbox" 
                checked={showHoleIntersections} 
                onChange={(e) => setShowHoleIntersections(e.target.checked)}
                className="rounded"
              />
              Hole Intersections
            </label>
            <label className="flex items-center gap-2 text-sm">
              <input 
                type="checkbox" 
                checked={exaggerateWaves} 
                onChange={(e) => setExaggerateWaves(e.target.checked)}
                className="rounded"
              />
              Exaggerate Waves
            </label>
          </div>
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* Fundamental frequency - Vertical */}
          <div>
            <h5 className="font-medium mb-2">Fundamental: {fundamental.toFixed(1)}Hz</h5>
            <svg width={verticalSvgWidth} height={verticalSvgHeight} className="border border-gray-100 bg-gray-50">
              {/* Grid */}
              <defs>
                <pattern id={`grid-${hole}-fund-v`} width="20" height="40" patternUnits="userSpaceOnUse">
                  <path d="M 0 40 L 0 0 20 0" fill="none" stroke="#f8f8f8" strokeWidth="1"/>
                </pattern>
                <marker id="arrowhead-v" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                  <polygon points="0 0, 8 3, 0 6" fill="#666" />
                </marker>
              </defs>
              <rect width="100%" height="100%" fill={`url(#grid-${hole}-fund-v)`} />
              
              {/* Vertical bore outline with wooden walls */}
              <rect
                x={(verticalSvgWidth / 2) - boreWidth / 2}
                y={startY}
                width={boreWidth}
                height={effectiveLength * verticalScale}
                fill="rgba(139, 69, 19, 0.1)"
                stroke="#8b4513"
                strokeWidth="2"
                opacity="0.6"
              />
              
              {/* Wooden wall indicators */}
              <line
                x1={(verticalSvgWidth / 2) - boreWidth / 2}
                y1={startY}
                x2={(verticalSvgWidth / 2) - boreWidth / 2}
                y2={startY + effectiveLength * verticalScale}
                stroke="#8b4513"
                strokeWidth="3"
                opacity="0.8"
              />
              <line
                x1={(verticalSvgWidth / 2) + boreWidth / 2}
                y1={startY}
                x2={(verticalSvgWidth / 2) + boreWidth / 2}
                y2={startY + effectiveLength * verticalScale}
                stroke="#8b4513"
                strokeWidth="3"
                opacity="0.8"
              />
              
              {/* Center line for wave reference */}
              <line
                x1={verticalSvgWidth / 2}
                y1={startY}
                x2={verticalSvgWidth / 2}
                y2={startY + effectiveLength * verticalScale}
                stroke="#666"
                strokeWidth="1"
                opacity="0.3"
                strokeDasharray="2,2"
              />
              
              {/* Sound radiation indicators - Vertical orientation */}
              {showSoundRadiation && (
                <g>
                  {/* Utaguchi (top end) - minimal sound leakage */}
                  <g opacity="0.3">
                    {[...Array(2)].map((_, i) => (
                      <path
                        key={`uta-v-${i}`}
                        d={`M ${verticalSvgWidth / 2} ${startY - 5} Q ${verticalSvgWidth / 2 - 8 - i * 2} ${startY - 15 - i * 5} ${verticalSvgWidth / 2 - 4 - i} ${startY - 18 - i * 6}`}
                        fill="none"
                        stroke="#4a90e2"
                        strokeWidth="0.5"
                        opacity={0.4 - i * 0.1}
                        strokeDasharray="2,2"
                      />
                    ))}
                    {[...Array(2)].map((_, i) => (
                      <path
                        key={`uta-v-r-${i}`}
                        d={`M ${verticalSvgWidth / 2} ${startY - 5} Q ${verticalSvgWidth / 2 + 8 + i * 2} ${startY - 15 - i * 5} ${verticalSvgWidth / 2 + 4 + i} ${startY - 18 - i * 6}`}
                        fill="none"
                        stroke="#4a90e2"
                        strokeWidth="0.5"
                        opacity={0.4 - i * 0.1}
                        strokeDasharray="2,2"
                      />
                    ))}
                    <text
                      x={verticalSvgWidth / 2 - 30}
                      y={startY - 20}
                      fontSize="7"
                      fill="#4a90e2"
                      textAnchor="middle"
                      opacity="0.6"
                    >
                      Minimal Leakage
                    </text>
                  </g>
                  
                  {/* Kan (bottom end) - primary sound radiation */}
                  <g opacity="0.8">
                    {[...Array(7)].map((_, i) => (
                      <path
                        key={`kan-v-${i}`}
                        d={`M ${verticalSvgWidth / 2} ${startY + effectiveLength * verticalScale + 5} Q ${verticalSvgWidth / 2 - 15 - i * 4} ${startY + effectiveLength * verticalScale + 20 + i * 12} ${verticalSvgWidth / 2 - 8 - i * 3} ${startY + effectiveLength * verticalScale + 30 + i * 15}`}
                        fill="none"
                        stroke="#e74c3c"
                        strokeWidth="1.5"
                        opacity={0.9 - i * 0.1}
                      />
                    ))}
                    {[...Array(7)].map((_, i) => (
                      <path
                        key={`kan-v-r-${i}`}
                        d={`M ${verticalSvgWidth / 2} ${startY + effectiveLength * verticalScale + 5} Q ${verticalSvgWidth / 2 + 15 + i * 4} ${startY + effectiveLength * verticalScale + 20 + i * 12} ${verticalSvgWidth / 2 + 8 + i * 3} ${startY + effectiveLength * verticalScale + 30 + i * 15}`}
                        fill="none"
                        stroke="#e74c3c"
                        strokeWidth="1.5"
                        opacity={0.9 - i * 0.1}
                      />
                    ))}
                    <text
                      x={verticalSvgWidth / 2 + 40}
                      y={startY + effectiveLength * verticalScale + 35}
                      fontSize="9"
                      fill="#e74c3c"
                      textAnchor="middle"
                      fontWeight="bold"
                    >
                      Primary Sound Output
                    </text>
                  </g>
                  
                  {/* Air flow direction indicator - Vertical */}
                  <g opacity="0.5">
                    <line
                      x1={verticalSvgWidth / 2 + boreWidth / 2 + 15}
                      y1={startY + 20}
                      x2={verticalSvgWidth / 2 + boreWidth / 2 + 15}
                      y2={startY + effectiveLength * verticalScale - 20}
                      stroke="#666"
                      strokeWidth="1"
                      markerEnd="url(#arrowhead-v)"
                      strokeDasharray="3,3"
                    />
                    <text
                      x={verticalSvgWidth / 2 + boreWidth / 2 + 25}
                      y={startY + effectiveLength * verticalScale / 2}
                      fontSize="8"
                      fill="#666"
                      textAnchor="middle"
                      transform={`rotate(90 ${verticalSvgWidth / 2 + boreWidth / 2 + 25} ${startY + effectiveLength * verticalScale / 2})`}
                    >
                      Air Flow (Holes Closed)
                    </text>
                  </g>
                </g>
              )}
              
              {/* Vertical multiple harmonic analysis */}
              {(() => {
                const { quality } = generateStandingWave(fundamental, effectiveLength, baseColor, holeData.position)
                
                // Calculate wooden bore effects
                const woodAcousticImpedance = 4.2e6
                const airAcousticImpedance = 415
                const reflectionCoeff = (woodAcousticImpedance - airAcousticImpedance) / (woodAcousticImpedance + airAcousticImpedance)
                
                // Define multiple harmonics for analysis
                const harmonics = [
                  { freq: fundamental, color: baseColor, opacity: showFundamental ? 0.9 : 0, label: 'Fundamental', strokeWidth: 2 },
                  { freq: fundamental * 1.5, color: '#ff6b6b', opacity: showHarmonics ? 0.7 : 0, label: '3rd Harmonic', strokeWidth: 1.5 },
                  { freq: fundamental * 2.5, color: '#4ecdc4', opacity: showHarmonics ? 0.6 : 0, label: '5th Harmonic', strokeWidth: 1.2 }
                ]
                
                const numPoints = Math.min(300, effectiveLength * 2)
                const maxBoreAmplitude = boreWidth / 2 - 4
                const endCorrection = 0.6 * boreDiameter
                const acousticLength = effectiveLength + endCorrection
                const waveCenterX = verticalSvgWidth / 2
                
                return (
                  <g>
                    {/* Generate multiple harmonic waves - Vertical */}
                    {harmonics.map((harmonic, idx) => {
                      if (harmonic.opacity === 0) return null
                      
                      const points: string[] = []
                      const baseAmplitude = Math.min(25 - (idx * 5), maxBoreAmplitude * (0.7 - idx * 0.1)) * exaggeration
                      const wavelength = speedOfSound / harmonic.freq
                      
                      for (let i = 0; i <= numPoints; i++) {
                        const position = (i / numPoints) * effectiveLength
                        const y = startY + position * verticalScale
                        
                        const k = (2 * Math.PI) / wavelength
                        const standingWaveAmplitude = Math.cos(k * (acousticLength - position))
                        
                        // Wall compression effects (stronger for higher harmonics)
                        const distanceFromWalls = Math.min(
                          Math.abs(waveCenterX - ((verticalSvgWidth / 2) - boreWidth / 2)),
                          Math.abs(waveCenterX - ((verticalSvgWidth / 2) + boreWidth / 2))
                        )
                        const wallCompressionFactor = 1 + (0.3 * reflectionCoeff * Math.exp(-distanceFromWalls / (10 - idx * 2)))
                        
                        // Apply wooden wall reflections (different for each harmonic)
                        const amplitude = baseAmplitude * wallCompressionFactor
                        const reflectedWave = reflectionCoeff * (0.2 + idx * 0.1) * Math.sin(k * position + Math.PI)
                        
                        // Ensure wave stays within bore boundaries - Horizontal displacement in vertical bore
                        const rawX = waveCenterX + amplitude * standingWaveAmplitude * Math.sin(k * position) + reflectedWave * amplitude
                        const minX = (verticalSvgWidth / 2) - maxBoreAmplitude + 2
                        const maxX = (verticalSvgWidth / 2) + maxBoreAmplitude - 2
                        const x = Math.max(minX, Math.min(maxX, rawX))
                        
                        points.push(`${x},${y}`)
                      }
                      
                      return (
                        <polyline
                          key={idx}
                          points={points.join(' ')}
                          fill="none"
                          stroke={harmonic.color}
                          strokeWidth={harmonic.strokeWidth}
                          opacity={harmonic.opacity}
                        />
                      )
                    })}
                    
                    {/* Wave concentration analysis points - Vertical */}
                    {showConcentration && (() => {
                      const concentrationPoints = []
                      
                      // Find concentration points where multiple harmonics align
                      for (let pos = 0; pos < effectiveLength; pos += effectiveLength / 20) {
                        const y = startY + pos * verticalScale
                        let totalAmplitude = 0
                        
                        harmonics.forEach(harmonic => {
                          if (harmonic.opacity > 0) {
                            const harmonicK = (2 * Math.PI) / (speedOfSound / harmonic.freq)
                            const amplitude = Math.cos(harmonicK * (acousticLength - pos)) * Math.sin(harmonicK * pos)
                            totalAmplitude += Math.abs(amplitude)
                          }
                        })
                        
                        if (totalAmplitude > 1.5) { // Threshold for concentration
                          concentrationPoints.push({ y, intensity: Math.min(totalAmplitude, 3) })
                        }
                      }
                      
                      return concentrationPoints.map((point, idx) => (
                        <circle
                          key={idx}
                          cx={waveCenterX}
                          cy={point.y}
                          r={3 + point.intensity}
                          fill="rgba(255, 215, 0, 0.7)"
                          stroke="#ffa500"
                          strokeWidth="1"
                          opacity="0.8"
                        />
                      ))
                    })()}
                    
                    {/* Hole position with intersection highlighting - Vertical */}
                    {showHoleIntersections && (
                      <g>
                        <line
                          x1={20}
                          y1={startY + holeData.position * verticalScale}
                          x2={verticalSvgWidth - 20}
                          y2={startY + holeData.position * verticalScale}
                          stroke={baseColor}
                          strokeWidth="3"
                          opacity="0.8"
                        />
                        
                        {/* Intersection points where waves cross the hole */}
                        <circle
                          cx={verticalSvgWidth / 2 - boreWidth / 2 - 8}
                          cy={startY + holeData.position * verticalScale}
                          r="6"
                          fill="rgba(255, 0, 0, 0.8)"
                          stroke="white"
                          strokeWidth="2"
                        />
                        <circle
                          cx={verticalSvgWidth / 2 + boreWidth / 2 + 8}
                          cy={startY + holeData.position * verticalScale}
                          r="6"
                          fill="rgba(255, 0, 0, 0.8)"
                          stroke="white"
                          strokeWidth="2"
                        />
                        
                        <rect
                          x={verticalSvgWidth / 2 - 8}
                          y={startY + holeData.position * verticalScale - 8}
                          width="16"
                          height="16"
                          fill="white"
                          stroke={baseColor}
                          strokeWidth="2"
                          rx="2"
                        />
                        <text
                          x={verticalSvgWidth / 2}
                          y={startY + holeData.position * verticalScale + 3}
                          fontSize="10"
                          fill={baseColor}
                          textAnchor="middle"
                          fontWeight="bold"
                        >
                          {hole}
                        </text>
                      </g>
                    )}
                    
                    {/* Quality and position info */}
                    <text
                      x={30}
                      y={startY + holeData.position * verticalScale}
                      fontSize="12"
                      fill={quality > 0.7 ? '#2ecc71' : quality > 0.4 ? '#f39c12' : '#e74c3c'}
                      textAnchor="middle"
                      fontWeight="bold"
                    >
                      Q: {(quality * 100).toFixed(0)}%
                    </text>
                    
                    <text
                      x={verticalSvgWidth - 30}
                      y={startY + holeData.position * verticalScale}
                      fontSize="8"
                      fill="#666"
                      textAnchor="middle"
                    >
                      {holeData.position.toFixed(1)}mm
                    </text>
                  </g>
                )
              })()}
              
              {/* Resonance nodes for fundamental */}
              {generateResonanceNodes(fundamental, effectiveLength).map((node, idx) => (
                <circle
                  key={idx}
                  cx={startX + node.position * verticalScale}
                  cy={verticalSvgWidth / 2}
                  r={node.type === 'antinode' ? 4 : 2}
                  fill={node.type === 'antinode' ? baseColor : '#fff'}
                  stroke={baseColor}
                  strokeWidth="1"
                  opacity="0.7"
                />
              ))}
            </svg>
            
            {/* Fundamental Analysis Legend */}
            <div className="mt-3 p-3 bg-blue-50 rounded-lg border border-blue-200">
              <h6 className="font-semibold text-blue-800 mb-2">Wave Analysis Legend</h6>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-2 text-xs">
                strokeWidth="1"
                opacity="0.3"
                strokeDasharray="2,2"
              />
              
              {/* Sound radiation indicators at both ends */}
              {/* Utaguchi (blowing end) - minimal sound leakage */}
              <g opacity="0.3">
                {[...Array(2)].map((_, i) => (
                  <path
                    key={`uta-${i}`}
                    d={`M ${startX - 5} ${individualSvgHeight / 2} Q ${startX - 15 - i * 5} ${individualSvgHeight / 2 - 8 - i * 2} ${startX - 18 - i * 6} ${individualSvgHeight / 2 - 4 - i}`}
                    fill="none"
                    stroke="#4a90e2"
                    strokeWidth="0.5"
                    opacity={0.4 - i * 0.1}
                    strokeDasharray="2,2"
                  />
                ))}
                {[...Array(2)].map((_, i) => (
                  <path
                    key={`uta-down-${i}`}
                    d={`M ${startX - 5} ${individualSvgHeight / 2} Q ${startX - 15 - i * 5} ${individualSvgHeight / 2 + 8 + i * 2} ${startX - 18 - i * 6} ${individualSvgHeight / 2 + 4 + i}`}
                    fill="none"
                    stroke="#4a90e2"
                    strokeWidth="0.5"
                    opacity={0.4 - i * 0.1}
                    strokeDasharray="2,2"
                  />
                ))}
                <text
                  x={startX - 25}
                  y={individualSvgHeight / 2 - 25}
                  fontSize="7"
                  fill="#4a90e2"
                  textAnchor="middle"
                  transform={`rotate(-90 ${startX - 25} ${individualSvgHeight / 2 - 25})`}
                  opacity="0.6"
                >
                  Minimal Leakage
                </text>
              </g>
              
              {/* Kan (bottom end) - primary sound radiation */}
              <g opacity="0.8">
                {[...Array(7)].map((_, i) => (
                  <path
                    key={`kan-${i}`}
                    d={`M ${startX + effectiveLength * scale * 0.9 + 5} ${individualSvgHeight / 2} Q ${startX + effectiveLength * scale * 0.9 + 20 + i * 12} ${individualSvgHeight / 2 - 15 - i * 4} ${startX + effectiveLength * scale * 0.9 + 30 + i * 15} ${individualSvgHeight / 2 - 8 - i * 3}`}
                    fill="none"
                    stroke="#e74c3c"
                    strokeWidth="1.5"
                    opacity={0.9 - i * 0.1}
                  />
                ))}
                {[...Array(7)].map((_, i) => (
                  <path
                    key={`kan-down-${i}`}
                    d={`M ${startX + effectiveLength * scale * 0.9 + 5} ${individualSvgHeight / 2} Q ${startX + effectiveLength * scale * 0.9 + 20 + i * 12} ${individualSvgHeight / 2 + 15 + i * 4} ${startX + effectiveLength * scale * 0.9 + 30 + i * 15} ${individualSvgHeight / 2 + 8 + i * 3}`}
                    fill="none"
                    stroke="#e74c3c"
                    strokeWidth="1.5"
                    opacity={0.9 - i * 0.1}
                  />
                ))}
                <text
                  x={startX + effectiveLength * scale * 0.9 + 35}
                  y={individualSvgHeight / 2 - 30}
                  fontSize="9"
                  fill="#e74c3c"
                  textAnchor="middle"
                  transform={`rotate(90 ${startX + effectiveLength * scale * 0.9 + 35} ${individualSvgHeight / 2 - 30})`}
                  fontWeight="bold"
                >
                  Primary Sound Output
                </text>
              </g>
              
              {/* Air flow direction indicator */}
              <g opacity="0.5">
                <defs>
                  <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
                    <polygon points="0 0, 8 3, 0 6" fill="#666" />
                  </marker>
                </defs>
                <line
                  x1={startX + 20}
                  y1={individualSvgHeight / 2 + (boreDiameter * scale * 0.9) / 2 + 15}
                  x2={startX + effectiveLength * scale * 0.9 - 20}
                  y2={individualSvgHeight / 2 + (boreDiameter * scale * 0.9) / 2 + 15}
                  stroke="#666"
                  strokeWidth="1"
                  markerEnd="url(#arrowhead)"
                  strokeDasharray="3,3"
                />
                <text
                  x={startX + effectiveLength * scale * 0.9 / 2}
                  y={individualSvgHeight / 2 + (boreDiameter * scale * 0.9) / 2 + 25}
                  fontSize="8"
                  fill="#666"
                  textAnchor="middle"
                >
                  Air Flow Direction (Holes Closed)
                </text>
              </g>
              
              {/* Multiple harmonic analysis with bore containment and wooden wall effects */}
              {(() => {
                const { quality } = generateStandingWave(fundamental, effectiveLength, baseColor, holeData.position)
                
                // Calculate wooden bore effects
                const woodAcousticImpedance = 4.2e6 // Wood acoustic impedance (kg/m²s)
                const airAcousticImpedance = 415 // Air acoustic impedance (kg/m²s)
                const reflectionCoeff = (woodAcousticImpedance - airAcousticImpedance) / (woodAcousticImpedance + airAcousticImpedance)
                
                // Define multiple harmonics for analysis
                const harmonics = [
                  { freq: fundamental, color: baseColor, opacity: 0.9, label: 'Fundamental', strokeWidth: 2 },
                  { freq: fundamental * 1.5, color: '#ff6b6b', opacity: 0.7, label: '3rd Harmonic', strokeWidth: 1.5 },
                  { freq: fundamental * 2.5, color: '#4ecdc4', opacity: 0.6, label: '5th Harmonic', strokeWidth: 1.2 }
                ]
                
                const numPoints = Math.min(300, effectiveLength * 2)
                const maxBoreAmplitude = (boreDiameter * scale * 0.9) / 2 - 4
                const endCorrection = 0.6 * boreDiameter
                const acousticLength = effectiveLength + endCorrection
                const waveCenterY = individualSvgHeight / 2
                
                return (
                  <g>
                    {/* Generate multiple harmonic waves */}
                    {harmonics.map((harmonic, idx) => {
                      const points: string[] = []
                      const baseAmplitude = Math.min(25 - (idx * 5), maxBoreAmplitude * (0.7 - idx * 0.1))
                      const wavelength = speedOfSound / harmonic.freq
                      
                      for (let i = 0; i <= numPoints; i++) {
                        const position = (i / numPoints) * effectiveLength
                        const x = startX + position * scale * 0.9
                        
                        const k = (2 * Math.PI) / wavelength
                        const standingWaveAmplitude = Math.cos(k * (acousticLength - position))
                        
                        // Wall compression effects (stronger for higher harmonics)
                        const distanceFromWalls = Math.min(
                          Math.abs(waveCenterY - ((individualSvgHeight / 2) - (boreDiameter * scale * 0.9) / 2)),
                          Math.abs(waveCenterY - ((individualSvgHeight / 2) + (boreDiameter * scale * 0.9) / 2))
                        )
                        const wallCompressionFactor = 1 + (0.3 * reflectionCoeff * Math.exp(-distanceFromWalls / (10 - idx * 2)))
                        
                        // Apply wooden wall reflections (different for each harmonic)
                        const amplitude = baseAmplitude * wallCompressionFactor
                        const reflectedWave = reflectionCoeff * (0.2 + idx * 0.1) * Math.sin(k * position + Math.PI)
                        
                        // Ensure wave stays within bore boundaries
                        const rawY = waveCenterY + amplitude * standingWaveAmplitude * Math.sin(k * position) + reflectedWave * amplitude
                        const minY = (individualSvgHeight / 2) - maxBoreAmplitude + 2
                        const maxY = (individualSvgHeight / 2) + maxBoreAmplitude - 2
                        const y = Math.max(minY, Math.min(maxY, rawY))
                        
                        points.push(`${x},${y}`)
                      }
                      
                      return (
                        <polyline
                          key={idx}
                          points={points.join(' ')}
                          fill="none"
                          stroke={harmonic.color}
                          strokeWidth={harmonic.strokeWidth}
                          opacity={harmonic.opacity}
                        />
                      )
                    })}
                    
                    {/* Wave concentration analysis points */}
                    {(() => {
                      const concentrationPoints = []
                      const fundamentalWavelength = speedOfSound / fundamental
                      
                      // Find concentration points where multiple harmonics align
                      for (let pos = 0; pos < effectiveLength; pos += effectiveLength / 20) {
                        const x = startX + pos * scale * 0.9
                        let totalAmplitude = 0
                        
                        harmonics.forEach(harmonic => {
                          const harmonicK = (2 * Math.PI) / (speedOfSound / harmonic.freq)
                          const amplitude = Math.cos(harmonicK * (acousticLength - pos)) * Math.sin(harmonicK * pos)
                          totalAmplitude += Math.abs(amplitude)
                        })
                        
                        if (totalAmplitude > 1.5) { // Threshold for concentration
                          concentrationPoints.push({ x, intensity: Math.min(totalAmplitude, 3) })
                        }
                      }
                      
                      return concentrationPoints.map((point, idx) => (
                        <circle
                          key={idx}
                          cx={point.x}
                          cy={waveCenterY}
                          r={3 + point.intensity}
                          fill="rgba(255, 215, 0, 0.7)"
                          stroke="#ffa500"
                          strokeWidth="1"
                          opacity="0.8"
                        />
                      ))
                    })()}
                    
                    {/* Reflection indicators at bore walls */}
                    <text
                      x={startX + 10}
                      y={(individualSvgHeight / 2) - (boreDiameter * scale * 0.9) / 2 - 5}
                      fontSize="9"
                      fill="#8b4513"
                      fontWeight="bold"
                    >
                      R={(reflectionCoeff * 100).toFixed(1)}%
                    </text>
                    
                    {/* Enhanced hole position marking */}
                    <g>
                      <line
                        x1={startX + holeData.position * scale * 0.9}
                        y1={20}
                        x2={startX + holeData.position * scale * 0.9}
                        y2={individualSvgHeight - 20}
                        stroke={baseColor}
                        strokeWidth="3"
                        opacity="0.8"
                      />
                      <circle
                        cx={startX + holeData.position * scale * 0.9}
                        cy={waveCenterY + maxBoreAmplitude - 8}
                        r="6"
                        fill="white"
                        stroke={baseColor}
                        strokeWidth="2"
                      />
                      <text
                        x={startX + holeData.position * scale * 0.9}
                        y={waveCenterY + maxBoreAmplitude - 5}
                        fontSize="10"
                        fill={baseColor}
                        textAnchor="middle"
                        fontWeight="bold"
                      >
                        {hole + 1}
                      </text>
                    </g>
                    
                    {/* Quality indicator with bore effects */}
                    <text
                      x={startX + holeData.position * scale * 0.9}
                      y={30}
                      fontSize="12"
                      fill={quality > 0.7 ? '#2ecc71' : quality > 0.4 ? '#f39c12' : '#e74c3c'}
                      textAnchor="middle"
                      fontWeight="bold"
                    >
                      Q: {(quality * 100).toFixed(0)}%
                    </text>
                    
                    {/* Hole position distance info */}
                    <text
                      x={startX + holeData.position * scale * 0.9}
                      y={individualSvgHeight - 5}
                      fontSize="8"
                      fill="#666"
                      textAnchor="middle"
                    >
                      {holeData.position.toFixed(1)}mm from utaguchi
                    </text>
                    
                    {/* Bore material info */}
                    <text
                      x={startX + effectiveLength * scale * 0.9 - 10}
                      y={(individualSvgHeight / 2) + (boreDiameter * scale * 0.9) / 2 + 15}
                      fontSize="8"
                      fill="#8b4513"
                      textAnchor="end"
                    >
                      Bamboo/Wood Impedance: {(woodAcousticImpedance / 1e6).toFixed(1)}M
                    </text>
                  </g>
                )
              })()}
              
              {/* Resonance nodes */}
              {generateResonanceNodes(fundamental, effectiveLength).map((node, idx) => (
                <circle
                  key={idx}
                  cx={startX + node.position * scale * 0.9}
                  cy={individualSvgHeight / 2}
                  r={node.type === 'antinode' ? 4 : 2}
                  fill={node.type === 'antinode' ? baseColor : '#fff'}
                  stroke={baseColor}
                  strokeWidth="1"
                  opacity="0.7"
                />
              ))}
            </svg>
          </div>
          
          {/* Upper octave - Vertical */}
          <div>
            <h5 className="font-medium mb-2">Upper Octave: {octave.toFixed(1)}Hz</h5>
            <svg width={verticalSvgWidth} height={verticalSvgHeight} className="border border-gray-100 bg-gray-50">
              {/* Grid */}
              <rect width="100%" height="100%" fill={`url(#grid-${hole}-fund-v)`} />
              
              {/* Vertical bore outline with wooden walls */}
              <rect
                x={(verticalSvgWidth / 2) - boreWidth / 2}
                y={startY}
                width={boreWidth}
                height={effectiveLength * verticalScale}
                fill="rgba(139, 69, 19, 0.1)"
                stroke="#8b4513"
                strokeWidth="2"
                opacity="0.6"
              />
              
              {/* Wooden wall indicators */}
              <line
                x1={(verticalSvgWidth / 2) - boreWidth / 2}
                y1={startY}
                x2={(verticalSvgWidth / 2) - boreWidth / 2}
                y2={startY + effectiveLength * verticalScale}
                stroke="#8b4513"
                strokeWidth="3"
                opacity="0.8"
              />
              <line
                x1={(verticalSvgWidth / 2) + boreWidth / 2}
                y1={startY}
                x2={(verticalSvgWidth / 2) + boreWidth / 2}
                y2={startY + effectiveLength * verticalScale}
                stroke="#8b4513"
                strokeWidth="3"
                opacity="0.8"
              />
              
              {/* Center line for wave reference */}
              <line
                x1={verticalSvgWidth / 2}
                y1={startY}
                x2={verticalSvgWidth / 2}
                y2={startY + effectiveLength * verticalScale}
                stroke="#666"
                strokeWidth="1"
                opacity="0.3"
                strokeDasharray="2,2"
              />
              
              {/* Sound radiation indicators - Vertical orientation for octave */}
              {showSoundRadiation && (
                <g>
                  {/* Enhanced radiation for octave frequency */}
                  <g opacity="0.9">
                    {[...Array(9)].map((_, i) => (
                      <path
                        key={`kan-oct-v-${i}`}
                        d={`M ${verticalSvgWidth / 2} ${startY + effectiveLength * verticalScale + 5} Q ${verticalSvgWidth / 2 - 18 - i * 5} ${startY + effectiveLength * verticalScale + 25 + i * 15} ${verticalSvgWidth / 2 - 10 - i * 4} ${startY + effectiveLength * verticalScale + 35 + i * 18}`}
                        fill="none"
                        stroke="#e74c3c"
                        strokeWidth="2"
                        opacity={1.0 - i * 0.1}
                      />
                    ))}
                    {[...Array(9)].map((_, i) => (
                      <path
                        key={`kan-oct-v-r-${i}`}
                        d={`M ${verticalSvgWidth / 2} ${startY + effectiveLength * verticalScale + 5} Q ${verticalSvgWidth / 2 + 18 + i * 5} ${startY + effectiveLength * verticalScale + 25 + i * 15} ${verticalSvgWidth / 2 + 10 + i * 4} ${startY + effectiveLength * verticalScale + 35 + i * 18}`}
                        fill="none"
                        stroke="#e74c3c"
                        strokeWidth="2"
                        opacity={1.0 - i * 0.1}
                      />
                    ))}
                    <text
                      x={verticalSvgWidth / 2 + 50}
                      y={startY + effectiveLength * verticalScale + 45}
                      fontSize="10"
                      fill="#e74c3c"
                      textAnchor="middle"
                      fontWeight="bold"
                    >
                      Enhanced Output (2×)
                    </text>
                  </g>
                </g>
              )}
              
              {/* Vertical multiple octave harmonic analysis */}
              {(() => {
                const { quality } = generateStandingWave(octave, effectiveLength, baseColor, holeData.position)
                
                // Wooden bore effects (same constants)
                const woodAcousticImpedance = 4.2e6
                const airAcousticImpedance = 415
                const reflectionCoeff = (woodAcousticImpedance - airAcousticImpedance) / (woodAcousticImpedance + airAcousticImpedance)
                
                // Define octave harmonics for analysis
                const octaveHarmonics = [
                  { freq: octave, color: baseColor, opacity: showFundamental ? 0.9 : 0, label: 'Octave', strokeWidth: 2 },
                  { freq: octave * 1.5, color: '#e74c3c', opacity: showHarmonics ? 0.7 : 0, label: 'Octave × 1.5', strokeWidth: 1.5 },
                  { freq: octave * 2, color: '#9b59b6', opacity: showHarmonics ? 0.6 : 0, label: 'Double Octave', strokeWidth: 1.2 }
                ]
                
                const numPoints = Math.min(300, effectiveLength * 2)
                const maxBoreAmplitude = boreWidth / 2 - 4
                const endCorrection = 0.6 * boreDiameter
                const acousticLength = effectiveLength + endCorrection
                const waveCenterX = verticalSvgWidth / 2
                
                return (
                  <g>
                    {/* Generate multiple octave harmonic waves - Vertical */}
                    {octaveHarmonics.map((harmonic, idx) => {
                      if (harmonic.opacity === 0) return null
                      
                      const points: string[] = []
                      const baseAmplitude = Math.min(20 - (idx * 4), maxBoreAmplitude * (0.6 - idx * 0.1)) * exaggeration // Smaller for octave
                      const wavelength = speedOfSound / harmonic.freq
                      
                      for (let i = 0; i <= numPoints; i++) {
                        const position = (i / numPoints) * effectiveLength
                        const y = startY + position * verticalScale
                        
                        const k = (2 * Math.PI) / wavelength
                        const standingWaveAmplitude = Math.cos(k * (acousticLength - position))
                        
                        // Wall compression effects (more pronounced for higher frequencies)
                        const distanceFromWalls = Math.min(
                          Math.abs(waveCenterX - ((verticalSvgWidth / 2) - boreWidth / 2)),
                          Math.abs(waveCenterX - ((verticalSvgWidth / 2) + boreWidth / 2))
                        )
                        const wallCompressionFactor = 1 + (0.4 * reflectionCoeff * Math.exp(-distanceFromWalls / (8 - idx))) // More compression for octave
                        
                        // Apply wooden wall reflections with higher frequency effects
                        const amplitude = baseAmplitude * wallCompressionFactor
                        const reflectedWave = reflectionCoeff * (0.3 + idx * 0.1) * Math.sin(k * position + Math.PI) // Stronger reflection for octave
                        
                        // Octave wave with bore containment - Horizontal displacement in vertical bore
                        const rawX = waveCenterX + amplitude * standingWaveAmplitude * Math.sin(k * position) + reflectedWave * amplitude
                        const minX = (verticalSvgWidth / 2) - maxBoreAmplitude + 2
                        const maxX = (verticalSvgWidth / 2) + maxBoreAmplitude - 2
                        const x = Math.max(minX, Math.min(maxX, rawX))
                        
                        points.push(`${x},${y}`)
                      }
                      
                      return (
                        <polyline
                          key={idx}
                          points={points.join(' ')}
                          fill="none"
                          stroke={harmonic.color}
                          strokeWidth={harmonic.strokeWidth}
                          opacity={harmonic.opacity}
                        />
                      )
                    })}
                    
                    {/* Octave wave concentration analysis points - Vertical */}
                    {showConcentration && (() => {
                      const concentrationPoints = []
                      
                      // Find concentration points for octave harmonics
                      for (let pos = 0; pos < effectiveLength; pos += effectiveLength / 25) { // More points for higher frequency
                        const y = startY + pos * verticalScale
                        let totalAmplitude = 0
                        
                        octaveHarmonics.forEach(harmonic => {
                          if (harmonic.opacity > 0) {
                            const harmonicK = (2 * Math.PI) / (speedOfSound / harmonic.freq)
                            const amplitude = Math.cos(harmonicK * (acousticLength - pos)) * Math.sin(harmonicK * pos)
                            totalAmplitude += Math.abs(amplitude)
                          }
                        })
                        
                        if (totalAmplitude > 1.3) { // Lower threshold for octave
                          concentrationPoints.push({ y, intensity: Math.min(totalAmplitude, 2.5) })
                        }
                      }
                      
                      return concentrationPoints.map((point, idx) => (
                        <circle
                          key={idx}
                          cx={waveCenterX}
                          cy={point.y}
                          r={2 + point.intensity}
                          fill="rgba(255, 140, 0, 0.8)"
                          stroke="#ff8c00"
                          strokeWidth="1"
                          opacity="0.9"
                        />
                      ))
                    })()}
                    
                    {/* Enhanced hole position marking for octave - Vertical */}
                    {showHoleIntersections && (
                      <g>
                        <line
                          x1={20}
                          y1={startY + holeData.position * verticalScale}
                          x2={verticalSvgWidth - 20}
                          y2={startY + holeData.position * verticalScale}
                          stroke={baseColor}
                          strokeWidth="3"
                          opacity="0.8"
                        />
                        
                        {/* Octave intersection points */}
                        <circle
                          cx={verticalSvgWidth / 2 - boreWidth / 2 - 10}
                          cy={startY + holeData.position * verticalScale}
                          r="7"
                          fill="rgba(255, 140, 0, 0.9)"
                          stroke="white"
                          strokeWidth="2"
                        />
                        <circle
                          cx={verticalSvgWidth / 2 + boreWidth / 2 + 10}
                          cy={startY + holeData.position * verticalScale}
                          r="7"
                          fill="rgba(255, 140, 0, 0.9)"
                          stroke="white"
                          strokeWidth="2"
                        />
                        
                        <rect
                          x={verticalSvgWidth / 2 - 10}
                          y={startY + holeData.position * verticalScale - 10}
                          width="20"
                          height="20"
                          fill="white"
                          stroke={baseColor}
                          strokeWidth="2"
                          rx="3"
                        />
                        <text
                          x={verticalSvgWidth / 2}
                          y={startY + holeData.position * verticalScale + 4}
                          fontSize="12"
                          fill={baseColor}
                          textAnchor="middle"
                          fontWeight="bold"
                        >
                          {hole}
                        </text>
                      </g>
                    )}
                    
                    {/* Quality indicator for octave */}
                    <text
                      x={30}
                      y={startY + holeData.position * verticalScale}
                      fontSize="12"
                      fill={quality > 0.7 ? '#2ecc71' : quality > 0.4 ? '#f39c12' : '#e74c3c'}
                      textAnchor="middle"
                      fontWeight="bold"
                    >
                      Q: {(quality * 100).toFixed(0)}%
                    </text>
                    
                    {/* Frequency info */}
                    <text
                      x={verticalSvgWidth - 30}
                      y={startY + holeData.position * verticalScale}
                      fontSize="8"
                      fill="#666"
                      textAnchor="middle"
                    >
                      {holeData.position.toFixed(1)}mm (2× freq)
                    </text>
                  </g>
                )
              })()}
              
              {/* Resonance nodes for octave */}
              {generateResonanceNodes(octave, effectiveLength).map((node, idx) => (
                <circle
                  key={idx}
                  cx={startX + node.position * scale * 0.9}
                  cy={individualSvgHeight / 2}
                  r={node.type === 'antinode' ? 4 : 2}
                  fill={node.type === 'antinode' ? baseColor : '#fff'}
                  stroke={baseColor}
                  strokeWidth="1"
                  opacity="0.7"
                />
              ))}
            </svg>
              <line
                x1={startX}
                y1={(individualSvgHeight / 2) + (boreDiameter * scale * 0.9) / 2}
                x2={startX + effectiveLength * scale * 0.9}
                y2={(individualSvgHeight / 2) + (boreDiameter * scale * 0.9) / 2}
                stroke="#8b4513"
                strokeWidth="3"
                opacity="0.8"
              />
              
              {/* Center line for wave reference */}
              <line
                x1={startX}
                y1={individualSvgHeight / 2}
                x2={startX + effectiveLength * scale * 0.9}
                y2={individualSvgHeight / 2}
                stroke="#666"
                strokeWidth="1"
                opacity="0.3"
                strokeDasharray="2,2"
              />
              
              {/* Multiple octave harmonic analysis with bore containment and wooden wall effects */}
              {(() => {
                const { quality } = generateStandingWave(octave, effectiveLength, baseColor, holeData.position)
                
                // Wooden bore effects (same constants)
                const woodAcousticImpedance = 4.2e6
                const airAcousticImpedance = 415
                const reflectionCoeff = (woodAcousticImpedance - airAcousticImpedance) / (woodAcousticImpedance + airAcousticImpedance)
                
                // Define octave harmonics for analysis
                const octaveHarmonics = [
                  { freq: octave, color: baseColor, opacity: 0.9, label: 'Octave', strokeWidth: 2 },
                  { freq: octave * 1.5, color: '#e74c3c', opacity: 0.7, label: 'Octave × 1.5', strokeWidth: 1.5 },
                  { freq: octave * 2, color: '#9b59b6', opacity: 0.6, label: 'Double Octave', strokeWidth: 1.2 }
                ]
                
                const numPoints = Math.min(300, effectiveLength * 2)
                const maxBoreAmplitude = (boreDiameter * scale * 0.9) / 2 - 4
                const endCorrection = 0.6 * boreDiameter
                const acousticLength = effectiveLength + endCorrection
                const waveCenterY = individualSvgHeight / 2
                
                return (
                  <g>
                    {/* Generate multiple octave harmonic waves */}
                    {octaveHarmonics.map((harmonic, idx) => {
                      const points: string[] = []
                      const baseAmplitude = Math.min(20 - (idx * 4), maxBoreAmplitude * (0.6 - idx * 0.1)) // Smaller for octave
                      const wavelength = speedOfSound / harmonic.freq
                      
                      for (let i = 0; i <= numPoints; i++) {
                        const position = (i / numPoints) * effectiveLength
                        const x = startX + position * scale * 0.9
                        
                        const k = (2 * Math.PI) / wavelength
                        const standingWaveAmplitude = Math.cos(k * (acousticLength - position))
                        
                        // Wall compression effects (more pronounced for higher frequencies)
                        const distanceFromWalls = Math.min(
                          Math.abs(waveCenterY - ((individualSvgHeight / 2) - (boreDiameter * scale * 0.9) / 2)),
                          Math.abs(waveCenterY - ((individualSvgHeight / 2) + (boreDiameter * scale * 0.9) / 2))
                        )
                        const wallCompressionFactor = 1 + (0.4 * reflectionCoeff * Math.exp(-distanceFromWalls / (8 - idx))) // More compression for octave
                        
                        // Apply wooden wall reflections with higher frequency effects
                        const amplitude = baseAmplitude * wallCompressionFactor
                        const reflectedWave = reflectionCoeff * (0.3 + idx * 0.1) * Math.sin(k * position + Math.PI) // Stronger reflection for octave
                        
                        // Octave wave with bore containment
                        const rawY = waveCenterY + amplitude * standingWaveAmplitude * Math.sin(k * position) + reflectedWave * amplitude
                        const minY = (individualSvgHeight / 2) - maxBoreAmplitude + 2
                        const maxY = (individualSvgHeight / 2) + maxBoreAmplitude - 2
                        const y = Math.max(minY, Math.min(maxY, rawY))
                        
                        points.push(`${x},${y}`)
                      }
                      
                      return (
                        <polyline
                          key={idx}
                          points={points.join(' ')}
                          fill="none"
                          stroke={harmonic.color}
                          strokeWidth={harmonic.strokeWidth}
                          opacity={harmonic.opacity}
                        />
                      )
                    })}
                    
                    {/* Octave wave concentration analysis points */}
                    {(() => {
                      const concentrationPoints = []
                      
                      // Find concentration points for octave harmonics
                      for (let pos = 0; pos < effectiveLength; pos += effectiveLength / 25) { // More points for higher frequency
                        const x = startX + pos * scale * 0.9
                        let totalAmplitude = 0
                        
                        octaveHarmonics.forEach(harmonic => {
                          const harmonicK = (2 * Math.PI) / (speedOfSound / harmonic.freq)
                          const amplitude = Math.cos(harmonicK * (acousticLength - pos)) * Math.sin(harmonicK * pos)
                          totalAmplitude += Math.abs(amplitude)
                        })
                        
                        if (totalAmplitude > 1.3) { // Lower threshold for octave
                          concentrationPoints.push({ x, intensity: Math.min(totalAmplitude, 2.5) })
                        }
                      }
                      
                      return concentrationPoints.map((point, idx) => (
                        <circle
                          key={idx}
                          cx={point.x}
                          cy={waveCenterY}
                          r={2 + point.intensity}
                          fill="rgba(255, 140, 0, 0.8)"
                          stroke="#ff8c00"
                          strokeWidth="1"
                          opacity="0.9"
                        />
                      ))
                    })()}
                    
                    {/* Enhanced reflection indicators for octave */}
                    <text
                      x={startX + 10}
                      y={(individualSvgHeight / 2) - (boreDiameter * scale * 0.9) / 2 - 5}
                      fontSize="9"
                      fill="#8b4513"
                      fontWeight="bold"
                    >
                      R={(reflectionCoeff * 100).toFixed(1)}% (Enhanced)
                    </text>
                    
                    {/* Enhanced hole position marking for octave */}
                    <g>
                      <line
                        x1={startX + holeData.position * scale * 0.9}
                        y1={20}
                        x2={startX + holeData.position * scale * 0.9}
                        y2={individualSvgHeight - 20}
                        stroke={baseColor}
                        strokeWidth="3"
                        opacity="0.8"
                      />
                      <rect
                        x={startX + holeData.position * scale * 0.9 - 6}
                        y={waveCenterY + maxBoreAmplitude - 10}
                        width="12"
                        height="12"
                        fill="white"
                        stroke={baseColor}
                        strokeWidth="2"
                        rx="2"
                      />
                      <text
                        x={startX + holeData.position * scale * 0.9}
                        y={waveCenterY + maxBoreAmplitude - 3}
                        fontSize="9"
                        fill={baseColor}
                        textAnchor="middle"
                        fontWeight="bold"
                      >
                        {hole + 1}
                      </text>
                    </g>
                    
                    {/* Quality indicator for octave */}
                    <text
                      x={startX + holeData.position * scale * 0.9}
                      y={30}
                      fontSize="12"
                      fill={quality > 0.7 ? '#2ecc71' : quality > 0.4 ? '#f39c12' : '#e74c3c'}
                      textAnchor="middle"
                      fontWeight="bold"
                    >
                      Q: {(quality * 100).toFixed(0)}%
                    </text>
                    
                    {/* Frequency-dependent damping info */}
                    <text
                      x={startX + effectiveLength * scale * 0.9 - 10}
                      y={(individualSvgHeight / 2) + (boreDiameter * scale * 0.9) / 2 + 15}
                      fontSize="8"
                      fill="#8b4513"
                      textAnchor="end"
                    >
                      Higher freq = more wall interaction
                    </text>
                    
                    {/* Octave hole position distance info */}
                    <text
                      x={startX + holeData.position * scale * 0.9}
                      y={individualSvgHeight - 5}
                      fontSize="8"
                      fill="#666"
                      textAnchor="middle"
                    >
                      {holeData.position.toFixed(1)}mm (2× frequency)
                    </text>
                  </g>
                )
              })()}
              
              {/* Resonance nodes for octave */}
              {generateResonanceNodes(octave, effectiveLength).map((node, idx) => (
                <circle
                  key={idx}
                  cx={startX + node.position * scale * 0.9}
                  cy={individualSvgHeight / 2}
                  r={node.type === 'antinode' ? 4 : 2}
                  fill={node.type === 'antinode' ? baseColor : '#fff'}
                  stroke={baseColor}
                  strokeWidth="1"
                  opacity="0.7"
                />
              ))}
            </svg>
            
            {/* Octave Acoustic Properties */}
            <div className="text-xs text-gray-600 mt-2 space-y-1">
              <div className="flex justify-between">
                <span>Wooden Bore Impedance:</span>
                <span className="font-mono">4.2×10⁶ kg/m²s</span>
              </div>
              <div className="flex justify-between">
                <span>Air Impedance:</span>
                <span className="font-mono">415 kg/m²s</span>
              </div>
              <div className="flex justify-between">
                <span>Reflection Coefficient:</span>
                <span className="font-mono text-amber-600">99.9%</span>
              </div>
              <div className="flex justify-between">
                <span>Wall Damping (2× frequency):</span>
                <span className="font-mono text-red-600">Enhanced</span>
              </div>
              <div className="flex justify-between">
                <span>Bore Confinement:</span>
                <span className="font-mono text-blue-600">Active</span>
              </div>
            </div>
            
            {/* Fundamental Analysis Legend */}
            <div className="mt-3 p-3 bg-blue-50 rounded-lg border border-blue-200">
              <h6 className="font-semibold text-blue-800 mb-2">Wave Analysis Legend</h6>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-2 text-xs">
                <div className="space-y-1">
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-0.5" style={{ backgroundColor: baseColor }}></div>
                    <span>Fundamental Wave</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-0.5 bg-red-400"></div>
                    <span>3rd Harmonic (1.5×)</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-0.5 bg-teal-400"></div>
                    <span>5th Harmonic (2.5×)</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 bg-yellow-400 rounded-full opacity-70"></div>
                    <span>Wave Concentration Points</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-0.5 bg-red-500"></div>
                    <span>Primary Sound Output (Kan)</span>
                  </div>
                </div>
                <div className="space-y-1">
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 bg-white border-2 rounded-full" style={{ borderColor: baseColor }}></div>
                    <span>Hole #{hole + 1} Position</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-2 bg-amber-100 border border-amber-600"></div>
                    <span>Wooden Bore Walls</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-0.5 border-dashed border-gray-400"></div>
                    <span>Wave Center Reference</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-0.5 bg-blue-400 opacity-30" style={{ borderStyle: 'dashed' }}></div>
                    <span>Minimal Utaguchi Leakage</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className="text-xs">→</span>
                    <span>Air Flow Direction</span>
                  </div>
                </div>
              </div>
            </div>
            
            {/* Octave Analysis Legend */}
            <div className="mt-3 p-3 bg-purple-50 rounded-lg border border-purple-200">
              <h6 className="font-semibold text-purple-800 mb-2">Octave Wave Analysis Legend</h6>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-2 text-xs">
                <div className="space-y-1">
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-0.5" style={{ backgroundColor: baseColor }}></div>
                    <span>Octave Wave (2× fundamental)</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-0.5 bg-red-500"></div>
                    <span>Octave × 1.5 Harmonic</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-4 h-0.5 bg-purple-500"></div>
                    <span>Double Octave (4× fundamental)</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 bg-orange-400 rounded-full opacity-80"></div>
                    <span>High-Freq Concentration</span>
                  </div>
                </div>
                <div className="space-y-1">
                  <div className="flex items-center gap-2">
                    <div className="w-3 h-3 bg-white border-2 rounded" style={{ borderColor: baseColor }}></div>
                    <span>Hole #{hole + 1} (Octave)</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className="text-xs font-mono text-amber-600">Enhanced</span>
                    <span>Higher Wall Reflection</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className="text-xs font-mono text-red-600">2× freq</span>
                    <span>Frequency Doubling Effect</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className="text-xs font-mono text-blue-600">Active</span>
                    <span>Enhanced Bore Confinement</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        {/* Analysis comparison */}
        <div className="mt-4 p-3 bg-gray-50 rounded-lg text-sm">
          <p><strong>Harmonic Analysis:</strong></p>
          <p>• The octave (2x frequency) shows twice as many wave cycles in the same length</p>
          <p>• Compare the node positions - octave harmonics should align with fundamental patterns</p>
          <p>• If hole position works well for fundamental but poorly for octave, consider slight adjustment</p>
        </div>
      </div>
    )
  }
  
  return (
    <div className="mt-6 p-4 bg-gray-50 rounded-lg">
      <h3 className="text-lg font-semibold text-gray-800 mb-4">
        Acoustic Standing Wave Analysis
      </h3>
      
      {/* Wave Toggle Controls */}
      <div className="mb-6 p-4 bg-white rounded-lg border border-gray-200">
        <h4 className="font-medium mb-3">Wave Visibility Controls</h4>
        <div className="flex flex-wrap gap-2 mb-4">
          {/* Base frequency toggle */}
          <button
            onClick={() => toggleWave(0)}
            className={`px-3 py-2 rounded-md text-sm font-medium transition-colors ${
              visibleWaves[0]
                ? 'bg-slate-700 text-white'
                : 'bg-gray-200 text-gray-600 hover:bg-gray-300'
            }`}
          >
            Base ({baseFrequency.toFixed(1)}Hz)
          </button>
          
          {/* Individual hole toggles */}
          {holePositions.map((hole, index) => {
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#34495e']
            const color = colors[index % colors.length]
            return (
              <button
                key={hole.hole}
                onClick={() => toggleWave(hole.hole)}
                className={`px-3 py-2 rounded-md text-sm font-medium transition-colors ${
                  visibleWaves[hole.hole]
                    ? 'text-white'
                    : 'bg-gray-200 text-gray-600 hover:bg-gray-300'
                }`}
                style={{
                  backgroundColor: visibleWaves[hole.hole] ? color : undefined
                }}
              >
                #{hole.hole} ({hole.noteName})
              </button>
            )
          })}
        </div>
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {/* Wave controls */}
          <div className="flex gap-2">
            <button
              onClick={() => {
                const allVisible: {[key: number]: boolean} = { 0: true }
                holePositions.forEach(hole => { allVisible[hole.hole] = true })
                setVisibleWaves(allVisible)
              }}
              className="px-3 py-1 text-xs bg-green-100 text-green-700 rounded hover:bg-green-200"
            >
              Show All Waves
            </button>
            <button
              onClick={() => {
                const allHidden: {[key: number]: boolean} = { 0: true } // Keep base visible
                holePositions.forEach(hole => { allHidden[hole.hole] = false })
                setVisibleWaves(allHidden)
              }}
              className="px-3 py-1 text-xs bg-red-100 text-red-700 rounded hover:bg-red-200"
            >
              Hide All Holes
            </button>
          </div>
          
          {/* Zoom controls */}
          <div className="flex items-center gap-2">
            <span className="text-sm font-medium text-gray-600">Zoom:</span>
            <button
              onClick={() => handleZoom(-0.25)}
              className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200"
              disabled={zoomLevel <= 0.5}
            >
              Zoom Out
            </button>
            <span className="text-xs font-mono bg-gray-100 px-2 py-1 rounded">
              {(zoomLevel * 100).toFixed(0)}%
            </span>
            <button
              onClick={() => handleZoom(0.25)}
              className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200"
              disabled={zoomLevel >= 5}
            >
              Zoom In
            </button>
            <button
              onClick={resetView}
              className="px-2 py-1 text-xs bg-gray-100 text-gray-700 rounded hover:bg-gray-200"
            >
              Reset
            </button>
          </div>
          
          {/* Hole visibility controls */}
          <div className="flex items-center gap-2">
            <span className="text-sm font-medium text-gray-600">Holes:</span>
            <button
              onClick={() => setShowHoles(!showHoles)}
              className={`px-3 py-1 text-xs rounded transition-colors ${
                showHoles
                  ? 'bg-purple-100 text-purple-700 hover:bg-purple-200'
                  : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
              }`}
            >
              {showHoles ? 'Hide Holes' : 'Show Holes'}
            </button>
          </div>
        </div>
      </div>
      
      {/* General Analysis Diagram */}
      <div className="mb-6 p-4 bg-white rounded-lg border border-gray-200">
        <h4 className="font-medium mb-3">Combined Wave Analysis</h4>
        <div className="text-sm text-gray-600 mb-4">
          Visualization shows standing wave patterns for each note frequency. 
          Use controls above to show/hide specific waves for clearer analysis.
        </div>
      
        <div className="overflow-x-auto">
          <svg 
            width={Math.max(svgWidth, svgWidth * zoomLevel)} 
            height={svgHeight} 
            className="border border-gray-200 bg-white"
            viewBox={`${panOffset} 0 ${svgWidth} ${svgHeight}`}
          >
            {/* Grid lines for reference */}
            <defs>
              <pattern id="acoustic-grid" width="50" height="20" patternUnits="userSpaceOnUse">
                <path d="M 50 0 L 0 0 0 20" fill="none" stroke="#f0f0f0" strokeWidth="1"/>
              </pattern>
            </defs>
            <rect width="100%" height="100%" fill="url(#acoustic-grid)" />
            
            {/* Center line (bore axis) - acoustic equilibrium */}
            <line
              x1={startX + panOffset}
              y1={centerY}
              x2={startX + fluteLength * scale * zoomLevel + panOffset}
              y2={centerY}
              stroke="#666"
              strokeWidth="1"
              opacity="0.4"
              strokeDasharray="2,2"
            />
            
            {/* Main bore centerline for reference */}
            <line
              x1={startX + panOffset}
              y1={centerY}
              x2={startX + fluteLength * scale * zoomLevel + panOffset}
              y2={centerY}
              stroke="#333"
              strokeWidth="2"
              opacity="0.3"
            />
            
            {/* Flute bore outline */}
            <rect
              x={startX + panOffset}
              y={centerY - (boreDiameter * scale * zoomLevel) / 2}
              width={fluteLength * scale * zoomLevel}
              height={boreDiameter * scale * zoomLevel}
              fill="none"
              stroke="#8b4513"
              strokeWidth="2"
              opacity="0.3"
            />
            
            {/* Bottom bore line - where holes are positioned */}
            <line
              x1={startX + panOffset}
              y1={centerY + (boreDiameter * scale * zoomLevel) / 2}
              x2={startX + fluteLength * scale * zoomLevel + panOffset}
              y2={centerY + (boreDiameter * scale * zoomLevel) / 2}
              stroke="#8b4513"
              strokeWidth="1"
              opacity="0.6"
              strokeDasharray="3,3"
            />
            
            {/* Utaguchi (blowing edge) - where waves originate */}
            <g>
              {/* Utaguchi edge */}
              <line
                x1={startX + panOffset}
                y1={centerY - (boreDiameter * scale * zoomLevel) / 2}
                x2={startX + panOffset}
                y2={centerY + (boreDiameter * scale * zoomLevel) / 2}
                stroke="#8b4513"
                strokeWidth="3"
                opacity="0.8"
              />
              
              {/* Utaguchi label */}
              {zoomLevel >= 0.75 && (
                <text
                  x={startX + panOffset - 15}
                  y={centerY - (boreDiameter * scale * zoomLevel) / 2 - 5}
                  fontSize={10 * Math.min(1.2, zoomLevel)}
                  fill="#8b4513"
                  textAnchor="middle"
                  fontWeight="bold"
                  transform={`rotate(-90, ${startX + panOffset - 15}, ${centerY - (boreDiameter * scale * zoomLevel) / 2 - 5})`}
                >
                  utaguchi
                </text>
              )}
              
              {/* Wave origin indicator - at top corner */}
              <circle
                cx={startX + panOffset}
                cy={centerY - (boreDiameter * scale * zoomLevel) / 2}
                r="3"
                fill="#ff6b6b"
                stroke="#8b4513"
                strokeWidth="1"
                opacity="0.8"
              />
              
              {/* Top corner marker */}
              <text
                x={startX + panOffset + 8}
                y={centerY - (boreDiameter * scale * zoomLevel) / 2 - 3}
                fontSize={8 * Math.min(1.2, zoomLevel)}
                fill="#ff6b6b"
                textAnchor="start"
                fontWeight="bold"
              >
                wave start
              </text>
            </g>
            
            {/* Visual holes on the flute */}
            {renderFluteholes()}
            
            {/* Generate standing waves for each hole's effective length */}
            {holePositions.map((hole, index) => {
              if (!visibleWaves[hole.hole]) return null // Skip if hidden
              
              const effectiveLength = hole.position // Distance from mouthpiece to hole
              const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#34495e']
              const color = colors[index % colors.length]
              
              // Generate zoomed wave points - proper sine wave oscillation around centerline
              const points: string[] = []
              const numPoints = Math.min(300, effectiveLength * 2 * zoomLevel) 
              const maxAmplitude = (boreDiameter * scale * zoomLevel) / 3 - 2 // Allow space for full oscillation
              const amplitude = Math.min(20, maxAmplitude * 0.8) // Proper amplitude for visible oscillation
              const wavelength = speedOfSound / hole.frequency
              const endCorrection = 0.6 * boreDiameter
              const acousticLength = effectiveLength + endCorrection
              
              // Start from utaguchi position
              const startPosition = startX + panOffset
              
              for (let i = 0; i <= numPoints; i++) {
                const position = (i / numPoints) * effectiveLength
                const x = startPosition + position * scale * zoomLevel
                
                const k = (2 * Math.PI) / wavelength
                const standingWaveAmplitude = Math.cos(k * (acousticLength - position))
                
                // Proper sine wave oscillation - goes both above and below centerline
                const y = centerY + amplitude * standingWaveAmplitude * Math.sin(k * position)
                
                points.push(`${x},${y}`)
              }
              
              const { quality } = generateStandingWave(hole.frequency, effectiveLength, color, hole.position)
              const resonanceNodes = generateResonanceNodes(hole.frequency, effectiveLength)
              
              return (
                <g key={hole.hole}>
                  {/* Standing wave for this hole - thinner line, contained in bore */}
                  <polyline
                    points={points.join(' ')}
                    fill="none"
                    stroke={color}
                    strokeWidth="1"
                    opacity="0.7"
                  />
                  
                  {/* Resonance nodes and antinodes */}
                  {resonanceNodes.map((node, nodeIndex) => (
                    <circle
                      key={`node-${hole.hole}-${nodeIndex}`}
                      cx={startX + node.position * scale * zoomLevel + panOffset}
                      cy={centerY}
                      r={node.type === 'antinode' ? 2.5 * Math.min(1.5, zoomLevel) : 1 * Math.min(1.5, zoomLevel)}
                      fill={node.type === 'antinode' ? color : '#fff'}
                      stroke={color}
                      strokeWidth="1"
                      opacity="0.5"
                    />
                  ))}
                  
                  {/* Hole position marker */}
                  <line
                    x1={startX + hole.position * scale * zoomLevel + panOffset}
                    y1={centerY - 60 * Math.min(1.5, zoomLevel)}
                    x2={startX + hole.position * scale * zoomLevel + panOffset}
                    y2={centerY + 60 * Math.min(1.5, zoomLevel)}
                    stroke={color}
                    strokeWidth={2 * Math.min(1.5, zoomLevel)}
                    opacity="0.6"
                  />
                  
                  {/* Labels - only show if zoom is reasonable */}
                  {zoomLevel >= 0.75 && (
                    <>
                      {/* Hole label with acoustic quality indicator */}
                      <text
                        x={startX + hole.position * scale * zoomLevel + panOffset}
                        y={centerY - 70 * Math.min(1.5, zoomLevel)}
                        fontSize={12 * Math.min(1.2, zoomLevel)}
                        fill={color}
                        textAnchor="middle"
                        fontWeight="bold"
                      >
                        #{hole.hole} ({hole.noteName})
                      </text>
                      
                      {/* Acoustic quality indicator */}
                      <text
                        x={startX + hole.position * scale * zoomLevel + panOffset}
                        y={centerY - 55 * Math.min(1.5, zoomLevel)}
                        fontSize={10 * Math.min(1.2, zoomLevel)}
                        fill={quality > 0.7 ? '#2ecc71' : quality > 0.4 ? '#f39c12' : '#e74c3c'}
                        textAnchor="middle"
                        fontWeight="bold"
                      >
                        Q: {(quality * 100).toFixed(0)}%
                      </text>
                      
                      {/* Frequency label */}
                      <text
                        x={startX + hole.position * scale * zoomLevel + panOffset}
                        y={centerY + 80 * Math.min(1.5, zoomLevel)}
                        fontSize={10 * Math.min(1.2, zoomLevel)}
                        fill={color}
                        textAnchor="middle"
                      >
                        {hole.frequency.toFixed(1)}Hz
                      </text>
                      
                      {/* Individual analysis button */}
                      <text
                        x={startX + hole.position * scale * zoomLevel + panOffset}
                        y={centerY + 95 * Math.min(1.5, zoomLevel)}
                        fontSize={9 * Math.min(1.2, zoomLevel)}
                        fill="blue"
                        textAnchor="middle"
                        className="cursor-pointer hover:underline"
                        onClick={() => setSelectedHole(selectedHole === hole.hole ? null : hole.hole)}
                      >
                        {selectedHole === hole.hole ? 'Hide' : 'Analyze'}
                      </text>
                    </>
                  )}
                </g>
              )
            })}
            
            {/* Base frequency wave (fundamental) - full length resonance */}
            {visibleWaves[0] && (() => {
              // Generate base frequency wave with proper sine wave oscillation
              const points: string[] = []
              const numPoints = Math.min(400, fluteLength * 2 * zoomLevel)
              const maxAmplitude = (boreDiameter * scale * zoomLevel) / 3 - 2
              const amplitude = Math.min(20, maxAmplitude * 0.8) // Proper oscillation amplitude
              const wavelength = speedOfSound / baseFrequency
              const endCorrection = 0.6 * boreDiameter
              const acousticLength = fluteLength + endCorrection
              
              // Start from utaguchi position
              const startPosition = startX + panOffset
              
              for (let i = 0; i <= numPoints; i++) {
                const position = (i / numPoints) * fluteLength
                const x = startPosition + position * scale * zoomLevel
                
                const k = (2 * Math.PI) / wavelength
                const standingWaveAmplitude = Math.cos(k * (acousticLength - position))
                
                // Proper sine wave oscillation around centerline
                const y = centerY + amplitude * standingWaveAmplitude * Math.sin(k * position)
                
                points.push(`${x},${y}`)
              }
              
              return (
                <polyline
                  points={points.join(' ')}
                  fill="none"
                  stroke="#2c3e50"
                  strokeWidth="1"
                  opacity="0.6"
                />
              )
            })()}
            
            {/* Legend - only show at reasonable zoom */}
            {zoomLevel >= 0.75 && (
              <>
                <text x={20 + panOffset} y={30} fontSize={14 * Math.min(1.2, zoomLevel)} fill="#2c3e50" fontWeight="bold">
                  Standing Wave Patterns (Middle C Range)
                </text>
                <text x={20 + panOffset} y={50} fontSize={12 * Math.min(1.2, zoomLevel)} fill="#2c3e50">
                  Base: {baseFrequency.toFixed(1)}Hz | Zoom: {(zoomLevel * 100).toFixed(0)}%
                </text>
                <text x={20 + panOffset} y={65} fontSize={10 * Math.min(1.2, zoomLevel)} fill="#8b4513">
                  Holes positioned on bottom bore line
                </text>
                <text x={20 + panOffset} y={80} fontSize={10 * Math.min(1.2, zoomLevel)} fill="#666">
                  Waves oscillate around centerline (dashed)
                </text>
              </>
            )}
            
            {/* Scale reference */}
            <text x={startX + panOffset} y={svgHeight - 10} fontSize={10 * Math.min(1.2, zoomLevel)} fill="#666" textAnchor="start">
              0mm
            </text>
            <text x={startX + fluteLength * scale * zoomLevel + panOffset} y={svgHeight - 10} fontSize={10 * Math.min(1.2, zoomLevel)} fill="#666" textAnchor="end">
              {fluteLength}mm
            </text>
          </svg>
        </div>
      </div>
      
      {/* Individual Wave Analysis Section */}
      <div className="mb-6">
        <h4 className="font-medium mb-3">Individual Note Analysis</h4>
        <div className="text-sm text-gray-600 mb-4">
          Click "Analyze" on any note in the diagram above to see detailed fundamental and octave wave analysis.
        </div>
        
        {/* Individual wave analysis for selected hole */}
        {selectedHole !== null && (() => {
          const holeData = holePositions.find(h => h.hole === selectedHole)
          return holeData ? <IndividualWaveAnalysis hole={selectedHole} holeData={holeData} /> : null
        })()}
        
        {selectedHole === null && (
          <div className="p-8 text-center text-gray-500 bg-white border border-gray-200 rounded-lg">
            Select a note from the diagram above to see detailed wave analysis
          </div>
        )}
      </div>      {/* Analysis notes */}
      <div className="mt-4 text-sm text-gray-600">
        <p><strong>How to read this enhanced acoustic analysis:</strong></p>
        <ul className="list-disc list-inside mt-2 space-y-1">
          <li><strong>Standing Waves:</strong> Each colored wave shows the pressure wave pattern inside the bore for that frequency</li>
          <li><strong>Visual Holes:</strong> Black circles show actual hole positions on the flute (toggle with "Show/Hide Holes")</li>
          <li><strong>Nodes & Antinodes:</strong> Large dots = pressure antinodes (maximum vibration), small dots = pressure nodes (minimum vibration)</li>
          <li><strong>Acoustic Quality (Q):</strong> Shows how well each hole aligns with optimal acoustic positions</li>
          <li><strong>Zoom Controls:</strong> Use zoom in/out to examine wave details more closely (50% to 500% zoom)</li>
          <li><span className="text-green-600 font-semibold">Green Q (&gt;70%):</span> Excellent acoustic coupling - hole well positioned</li>
          <li><span className="text-yellow-600 font-semibold">Yellow Q (40-70%):</span> Good but could be optimized</li>
          <li><span className="text-red-600 font-semibold">Red Q (&lt;40%):</span> Poor positioning - consider adjusting hole location</li>
          <li><strong>Wave Controls:</strong> Use the toggle buttons to show/hide specific waves for clearer analysis</li>
          <li><strong>Individual Analysis:</strong> Click "Analyze" on any note to see detailed fundamental and octave comparison</li>
        </ul>
        
        <div className="mt-4 p-3 bg-blue-50 rounded-lg">
          <p><strong>For Flute Makers:</strong> Use the zoom feature to examine wave patterns in detail around specific hole positions. The visual holes show exactly where air exits the bore. Compare fundamental and octave waves in individual analysis to ensure harmonic consistency. If the acoustic quality (Q) is low, consider fine-tuning the hole position by ±2-3mm to better align with pressure antinodes.</p>
        </div>
        
        <div className="mt-2 p-3 bg-yellow-50 rounded-lg">
          <p><strong>Pro Tips:</strong> Zoom in (200-300%) for detailed wave analysis. Hide waves to focus on specific notes. Toggle holes off for cleaner wave visualization. Use individual analysis to check harmonic relationships.</p>
        </div>
      </div>
    </div>
  )
}
